<%# Product Pages Index - List of monitored PDPs with inline product picker %>

<s-page heading="Monitored pages">
  <% if @can_add_more %>
  <s-button slot="primary-action" variant="primary" id="open-product-picker">Add products</s-button>
  <% end %>
  <s-link slot="breadcrumb-actions" href="<%= root_path(host: @host) %>">Dashboard</s-link>
  <s-badge slot="accessory" tone="info"><%= @product_pages_count %>/<%= @shop_setting&.max_monitored_pages || 5 %></s-badge>
</s-page>

<% if @product_pages_count > 0 %>
<%# Product list - Thumbnail | Title | Status | Actions %>
<s-section>
  <s-stack gap="none">
    <% @product_pages.each do |page| %>
    <s-box border="base" padding="base">
      <s-grid gridTemplateColumns="auto 1fr auto auto" gap="base" alignItems="center">
        <%# Thumbnail + Title (clickable) %>
        <s-link href="<%= product_page_path(page, host: @host) %>">
          <s-thumbnail src="<%= page.image_url.presence || 'https://cdn.shopify.com/s/files/1/0533/2089/files/placeholder-images-image_large.png' %>" alt="<%= page.title %>" size="small"></s-thumbnail>
        </s-link>

        <s-link href="<%= product_page_path(page, host: @host) %>" tone="neutral">
          <%= page.title %>
        </s-link>

        <%# Status badge %>
        <s-badge tone="<%= page.status == 'healthy' ? 'success' : (page.status == 'critical' ? 'critical' : (page.status == 'warning' ? 'attention' : 'info')) %>">
          <%= page.status.capitalize %>
        </s-badge>

        <%# Action buttons %>
        <s-stack direction="inline" gap="tight">
          <s-button href="<%= product_page_path(page, host: @host) %>">View</s-button>
          <s-button onclick="rescanProduct('<%= rescan_product_page_path(page, host: @host) %>')">Rescan</s-button>
          <s-button tone="critical" onclick="deleteProduct('<%= product_page_path(page, host: @host) %>', '<%= page.title %>')">Remove</s-button>
        </s-stack>
      </s-grid>
    </s-box>
    <% end %>
  </s-stack>
</s-section>

<%# Remaining slots info %>
<% if @can_add_more %>
<s-box paddingBlockStart="small">
  <s-section padding="base">
    <s-stack direction="inline" gap="base" align="center">
      <s-icon type="info" tone="info"></s-icon>
      <s-paragraph>
        <%= @remaining_slots %> slot<%= @remaining_slots > 1 ? 's' : '' %> remaining Â·
        <a href="#" id="add-more-link" style="color: inherit;">Add more products</a>
      </s-paragraph>
    </s-stack>
  </s-section>
</s-box>
<% end %>

<% else %>
<%# Empty state - Shopify pattern %>
<s-section padding="base">
  <s-grid gap="base" justifyItems="center" paddingBlock="large-400">
    <s-box maxInlineSize="200px" maxBlockSize="200px">
      <s-image aspectRatio="1/0.5" src="https://cdn.shopify.com/s/files/1/0262/4071/2726/files/emptystate-files.png" alt="Add products to monitor" />
    </s-box>
    <s-grid justifyItems="center" maxInlineSize="450px" gap="base">
      <s-heading>No product pages monitored yet</s-heading>
      <s-paragraph>
        Add up to <%= @shop_setting&.max_monitored_pages || 5 %> product pages to start monitoring for JavaScript errors, broken UI elements, and performance issues.
      </s-paragraph>
      <s-button id="open-product-picker-empty" variant="primary">
        Add products
      </s-button>
    </s-grid>
  </s-grid>
</s-section>
<% end %>


<!-- Store data for JavaScript (Resource Picker) -->
<div id="picker-config" data-create-url="<%= product_pages_path %>" data-redirect-url="<%= product_pages_path(host: @host) %>" data-monitored-gids="<%= @monitored_product_gids.to_json %>" data-max-selections="<%= @remaining_slots %>" data-csrf-token="<%= form_authenticity_token %>" style="display: none;">
</div>

<% content_for :javascript do %>
<script>
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content ||
                    document.getElementById('picker-config')?.dataset?.csrfToken || '';

  async function deleteProduct(url, title) {
    if (!confirm(`Remove ${title} from monitoring?`)) return;

    try {
      const headers = {
        'X-CSRF-Token': csrfToken,
        'Accept': 'text/html'
      };

      try {
        const token = await shopify.idToken();
        if (token) headers['Authorization'] = `Bearer ${token}`;
      } catch (e) {
        console.warn('Could not get session token for delete:', e);
      }

      const response = await fetch(url, {
        method: 'DELETE',
        headers: headers,
        credentials: 'same-origin',
        redirect: 'manual'
      });

      // 302 redirect means success (controller redirects after destroy)
      // type 'opaqueredirect' is what fetch returns when redirect: 'manual' intercepts a redirect
      if (response.ok || response.type === 'opaqueredirect' || (response.status >= 300 && response.status < 400)) {
        shopify.toast.show('Product removed from monitoring.', { duration: 3000 });
        setTimeout(() => window.location.reload(), 500);
      } else {
        throw new Error(`Server returned ${response.status}`);
      }
    } catch (error) {
      console.error('Delete failed:', error);
      shopify.toast.show('Failed to remove product. Please try again.', {
        duration: 3000,
        isError: true
      });
    }
  }

  async function rescanProduct(url) {
    try {
      const headers = {
        'X-CSRF-Token': csrfToken,
        'Accept': 'text/html'
      };

      try {
        const token = await shopify.idToken();
        if (token) headers['Authorization'] = `Bearer ${token}`;
      } catch (e) {
        console.warn('Could not get session token for rescan:', e);
      }

      shopify.toast.show('Rescan started...', { duration: 2000 });

      const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        credentials: 'same-origin',
        redirect: 'manual'
      });

      if (response.ok || response.type === 'opaqueredirect' || (response.status >= 300 && response.status < 400)) {
        shopify.toast.show('Rescan completed!', { duration: 3000 });
        setTimeout(() => window.location.reload(), 500);
      } else {
        throw new Error(`Server returned ${response.status}`);
      }
    } catch (error) {
      console.error('Rescan failed:', error);
      shopify.toast.show('Failed to rescan. Please try again.', {
        duration: 3000,
        isError: true
      });
    }
  }

  document.addEventListener('DOMContentLoaded', function() {
    const config = document.getElementById('picker-config');
    const createUrl = config.dataset.createUrl;
    const redirectUrl = config.dataset.redirectUrl;
    const monitoredProductIds = JSON.parse(config.dataset.monitoredGids || '[]');
    const maxSelections = parseInt(config.dataset.maxSelections, 10);
    const csrfToken = config.dataset.csrfToken;

    // Attach picker to all Add Product buttons
    const pickerButtons = [
      document.getElementById('open-product-picker'),
      document.getElementById('open-product-picker-empty'),
      document.getElementById('add-more-link')
    ].filter(Boolean);

    pickerButtons.forEach(function(btn) {
      btn.addEventListener('click', async function(e) {
        e.preventDefault();

        if (maxSelections <= 0) {
          shopify.toast.show('You have reached the maximum number of monitored pages.', {
            duration: 3000
          });
          return;
        }

        try {
          const selected = await shopify.resourcePicker({
            type: 'product',
            action: 'select',
            multiple: maxSelections > 1 ? maxSelections : false,
            filter: {
              draft: false,
              archived: false,
              variants: false
            }
          });

          console.log('Resource Picker returned:', selected);

          if (selected && selected.length > 0) {
            const newProducts = selected.filter(product =>
              !monitoredProductIds.includes(product.id)
            );
            const skippedCount = selected.length - newProducts.length;

            if (newProducts.length === 0) {
              shopify.toast.show('All selected products are already being monitored.', {
                duration: 3000
              });
              return;
            }

            if (skippedCount > 0) {
              shopify.toast.show(`${skippedCount} product(s) already monitored and skipped.`, {
                duration: 3000
              });
            }

            // Show loading
            btn.disabled = true;
            if (btn.tagName === 'S-BUTTON') btn.textContent = 'Adding...';

            const params = new URLSearchParams();
            params.append('authenticity_token', csrfToken);

            newProducts.forEach((product, index) => {
              const numericId = product.id.split('/').pop();
              params.append(`products[${index}][shopify_product_id]`, numericId);
              params.append(`products[${index}][handle]`, product.handle);
              params.append(`products[${index}][title]`, product.title);

              // Extract image URL from the Resource Picker response
              const imageUrl = product.images && product.images.length > 0 ?
                product.images[0].originalSrc :
                '';
              params.append(`products[${index}][image_url]`, imageUrl);
            });

            let token;
            try {
              token = await shopify.idToken();
            } catch (tokenError) {
              console.warn('Could not get session token:', tokenError);
            }

            const headers = {
              'Content-Type': 'application/x-www-form-urlencoded',
              'X-CSRF-Token': csrfToken,
              'Accept': 'application/json, text/html'
            };
            if (token) headers['Authorization'] = `Bearer ${token}`;

            const response = await fetch(createUrl, {
              method: 'POST',
              headers: headers,
              body: params.toString(),
              credentials: 'same-origin'
            });

            if (response.ok) {
              shopify.toast.show(`Added ${newProducts.length} product(s) to monitoring!`, {
                duration: 3000
              });
              setTimeout(() => {
                window.location.href = redirectUrl;
              }, 500);
            } else {
              const errorText = await response.text();
              console.error('Failed to add products:', response.status, errorText);
              throw new Error(`Server returned ${response.status}`);
            }
          }
        } catch (error) {
          console.error('Error:', error);
          shopify.toast.show('Failed to add products. Please try again.', {
            duration: 3000,
            isError: true
          });
          btn.disabled = false;
          if (btn.tagName === 'S-BUTTON') btn.textContent = 'Add Product';
        }
      });
    });
  });
</script>
<% end %>